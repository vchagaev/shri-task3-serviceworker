[![Build Status](https://travis-ci.org/vchagaev/shri-task3-serviceworker.svg?branch=master)](https://travis-ci.org/vchagaev/shri-task3-serviceworker)

#Задание №3 ServiceWorker

##Начало
Для понимания с чем я вообще буду иметь дело (до этого с ServiceWorker’ом не работал) я решил изучить его подробнее. Прочитал статью на MDN, статью Девида Уэлша, пролистал Cookbook и спецификацию.
Понял, что в Chrome Developer Tools есть возможность дебажить сервис воркеры (https://www.chromium.org/blink/serviceworker/service-worker-faq).

##Знакомство и первый баг
Открыл проект в WebStorm и запустил его, чтобы посмотреть что он из себя представляет. В дебагере DevTools сразу отловил ошибку в воркере о лишней точке с запятой. С помощью подсветки и валидации JS в IDE без проблем нашел и исправил. Ошибка скорее всего возникла из-за невнимательности. Все мы люди и имеем свойство ошибаться, но IDE и разные code quality tools помогают делать это реже. Я использую JSCS и ESLint. JSCS следит за кодстайлом, а ESLint за ошибками коде. Конфиги взял с https://github.com/ymaps/codestyle

##Точно закэшировалось?
После исправления этой ошибки приложение заработало, но работало оно только когда имелось подключение к интернету. Управлял подключением к интернету на вкладке Network в DevTools. В Resources в кэш попали js и css, но не были найдены на сервере. Оказалось к ним был указан неверный путь при установке воркера. Плюс ко всему добавил саму страничку `index.html`. Эту ошибку тоже можно отнести к невнимательности и к тому что разработчик даже не посмотрел на состояние кэша своего воркера, т.е. плохо проверил. Но приложение все еще работало только онлайн.

##Неверный scope
Столкнулся с проблемой, что событие `fetch` не отлавливалось. Нашел ответ на Stackoverflow и сравнил с рабочими вариантами. Проблема была в неправильном scope у воркера. Переложил его в корень и указал явно весь scope. В статьях на это внимание особо не акцентируют и в спецификации вроде тоже явно не написано.

##Промисы...
В итоге приложение стало частично работать оффлайн, но картинки не загружались и в консоли были ошибки про <http://localhost:8080/undefined> и предупреждения про reject промиса. В итоге оказалось, что в `catch` промиса ожидали ответ, хотя в него передается ошибка. Можно решить двумя способами 1)С ошибкой передавать request  2) в catch использовать request из замыкания. Я выбрал второй вариант, т.к. ошибка есть ошибка, а нам нужен общий запрос.
Приложение стало отображать картинки в оффлайн режиме. Но у нас осталась еще одна проблемы - при плохом соединении после добавления студента список со студентами не обновлялся. После изучения кода, понял что ошибка в использовании race при получении данных о студентах с сервера. Промис из кэша срабатывает быстрей. Видимо, изначально идея была в том, что если у пользователя плохое соединение, то используем кэш. В данном реализации это могло привести к невозможности обновить список студентов при плохом соединении (соединение есть, но плохое). Промис `fetch` недоступность сервера отлавливает в `catch`. Я использовал эту фичу для определения невозможности загрузки данных с сервера. Для консистентности  убрал catch в `fetchAndPutToCache` и вынес его на уровень выше с использование нашей функции `getFromCache`. Привел к единообразию вызов анонимных функций, код стайл и добавил комменты к функциям.

##Тюнинг
После исправления ошибок с промисами картинки стали доступны офлайн, но было одно НО. Если после первой загрузки старницы уйти в оффлайн, то картинки не будут доступны. Я решил подтюнить поведение воркера, чтобы он при первой же загрузке кэшировал все необходимые данные (работа с ссылками на фото студентов при установке).

##Оффлайн добавление
Теоретически изучил реализацию оффлайн добавления. Для определения состояния лучше использовать offline.js, т.к. navigator.online отображает не доступность сервера, а именно подключение к сети + не во всех браузерах. Основная идея - добавлять запросы в очередь (offline.js имеет такую фичу) и когда пользователь переходит в онлайн, то запросы отправляются в соответсвующем порядке. НО у нас кэшируется JSON со всеми студентами и во время офлайн работы нам нужно эмулировать что сервер как бы получил наши запросы, т.е. изменять ответ из кэша.